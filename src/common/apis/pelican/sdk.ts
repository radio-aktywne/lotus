// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from "./client";
import {
  BindingsCreateRequestSchema,
  BindingsCreateResponseSchema,
  BindingsIdDeleteRequestSchema,
  BindingsIdDeleteResponseSchema,
  BindingsIdGetRequestSchema,
  BindingsIdGetResponseSchema,
  BindingsIdUpdateRequestSchema,
  BindingsIdUpdateResponseSchema,
  BindingsListRequestSchema,
  BindingsListResponseSchema,
  MediaCreateRequestSchema,
  MediaCreateResponseSchema,
  MediaIdContentDownloadRequestSchema,
  MediaIdContentDownloadResponseSchema,
  MediaIdContentHeaddownloadRequestSchema,
  MediaIdContentUploadRequestSchema,
  MediaIdContentUploadResponseSchema,
  MediaIdDeleteRequestSchema,
  MediaIdDeleteResponseSchema,
  MediaIdGetRequestSchema,
  MediaIdGetResponseSchema,
  MediaIdUpdateRequestSchema,
  MediaIdUpdateResponseSchema,
  MediaListRequestSchema,
  MediaListResponseSchema,
  PingHeadpingRequestSchema,
  PingHeadpingResponseSchema,
  PingPingRequestSchema,
  PingPingResponseSchema,
  PlaylistsCreateRequestSchema,
  PlaylistsCreateResponseSchema,
  PlaylistsIdDeleteRequestSchema,
  PlaylistsIdDeleteResponseSchema,
  PlaylistsIdGetRequestSchema,
  PlaylistsIdGetResponseSchema,
  PlaylistsIdM3uHeadm3uRequestSchema,
  PlaylistsIdM3Um3uRequestSchema,
  PlaylistsIdM3Um3uResponseSchema,
  PlaylistsIdUpdateRequestSchema,
  PlaylistsIdUpdateResponseSchema,
  PlaylistsListRequestSchema,
  PlaylistsListResponseSchema,
  SseSubscribeRequestSchema,
  SseSubscribeResponseSchema,
  TestTestRequestSchema,
  TestTestResponseSchema,
} from "./schemas";
import type {
  BindingsCreateErrors,
  BindingsCreateRequest,
  BindingsCreateResponses,
  BindingsIdDeleteErrors,
  BindingsIdDeleteRequest,
  BindingsIdDeleteResponses,
  BindingsIdGetErrors,
  BindingsIdGetRequest,
  BindingsIdGetResponses,
  BindingsIdUpdateErrors,
  BindingsIdUpdateRequest,
  BindingsIdUpdateResponses,
  BindingsListErrors,
  BindingsListRequest,
  BindingsListResponses,
  MediaCreateErrors,
  MediaCreateRequest,
  MediaCreateResponses,
  MediaIdContentDownloadErrors,
  MediaIdContentDownloadRequest,
  MediaIdContentDownloadResponses,
  MediaIdContentHeaddownloadErrors,
  MediaIdContentHeaddownloadRequest,
  MediaIdContentHeaddownloadResponses,
  MediaIdContentUploadErrors,
  MediaIdContentUploadRequest,
  MediaIdContentUploadResponses,
  MediaIdDeleteErrors,
  MediaIdDeleteRequest,
  MediaIdDeleteResponses,
  MediaIdGetErrors,
  MediaIdGetRequest,
  MediaIdGetResponses,
  MediaIdUpdateErrors,
  MediaIdUpdateRequest,
  MediaIdUpdateResponses,
  MediaListErrors,
  MediaListRequest,
  MediaListResponses,
  PingHeadpingRequest,
  PingHeadpingResponses,
  PingPingRequest,
  PingPingResponses,
  PlaylistsCreateErrors,
  PlaylistsCreateRequest,
  PlaylistsCreateResponses,
  PlaylistsIdDeleteErrors,
  PlaylistsIdDeleteRequest,
  PlaylistsIdDeleteResponses,
  PlaylistsIdGetErrors,
  PlaylistsIdGetRequest,
  PlaylistsIdGetResponses,
  PlaylistsIdM3uHeadm3uErrors,
  PlaylistsIdM3uHeadm3uRequest,
  PlaylistsIdM3uHeadm3uResponses,
  PlaylistsIdM3Um3uErrors,
  PlaylistsIdM3Um3uRequest,
  PlaylistsIdM3Um3uResponses,
  PlaylistsIdUpdateErrors,
  PlaylistsIdUpdateRequest,
  PlaylistsIdUpdateResponses,
  PlaylistsListErrors,
  PlaylistsListRequest,
  PlaylistsListResponses,
  SseSubscribeErrors,
  SseSubscribeRequest,
  SseSubscribeResponses,
  TestTestErrors,
  TestTestRequest,
  TestTestResponses,
} from "./types";

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

class HeyApiClient {
  protected client: Client;

  constructor(args: { client: Client }) {
    this.client = args.client;
  }
}

class HeyApiRegistry<T> {
  private readonly defaultKey = "default";

  private readonly instances: Map<string, T> = new Map();

  get(key?: string): T {
    const instance = this.instances.get(key ?? this.defaultKey);
    if (!instance) {
      throw new Error(
        `No SDK client found. Create one with "new Sdk()" to fix this error.`,
      );
    }
    return instance;
  }

  set(value: T, key?: string): void {
    this.instances.set(key ?? this.defaultKey, value);
  }
}

export class Sdk extends HeyApiClient {
  public static readonly __registry = new HeyApiRegistry<Sdk>();

  constructor(args: { client: Client; key?: string }) {
    super(args);
    Sdk.__registry.set(this, args.key);
  }

  /**
   * List bindings
   *
   * List bindings that match the request.
   */
  public bindingsList<ThrowOnError extends boolean = false>(
    options?: Options<BindingsListRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      BindingsListResponses,
      BindingsListErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await BindingsListRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await BindingsListResponseSchema.parseAsync(data),
      url: "/bindings",
      ...options,
    });
  }

  /**
   * Create binding
   *
   * Create a new binding.
   */
  public bindingsCreate<ThrowOnError extends boolean = false>(
    options: Options<BindingsCreateRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      BindingsCreateResponses,
      BindingsCreateErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await BindingsCreateRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await BindingsCreateResponseSchema.parseAsync(data),
      url: "/bindings",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Delete binding
   *
   * Delete a binding by ID.
   */
  public bindingsIdDelete<ThrowOnError extends boolean = false>(
    options: Options<BindingsIdDeleteRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).delete<
      BindingsIdDeleteResponses,
      BindingsIdDeleteErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await BindingsIdDeleteRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await BindingsIdDeleteResponseSchema.parseAsync(data),
      url: "/bindings/{id}",
      ...options,
    });
  }

  /**
   * Get binding
   *
   * Get a binding by ID.
   */
  public bindingsIdGet<ThrowOnError extends boolean = false>(
    options: Options<BindingsIdGetRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      BindingsIdGetResponses,
      BindingsIdGetErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await BindingsIdGetRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await BindingsIdGetResponseSchema.parseAsync(data),
      url: "/bindings/{id}",
      ...options,
    });
  }

  /**
   * Update binding
   *
   * Update a binding by ID.
   */
  public bindingsIdUpdate<ThrowOnError extends boolean = false>(
    options: Options<BindingsIdUpdateRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).patch<
      BindingsIdUpdateResponses,
      BindingsIdUpdateErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await BindingsIdUpdateRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await BindingsIdUpdateResponseSchema.parseAsync(data),
      url: "/bindings/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * List media
   *
   * List media that match the request.
   */
  public mediaList<ThrowOnError extends boolean = false>(
    options?: Options<MediaListRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      MediaListResponses,
      MediaListErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await MediaListRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await MediaListResponseSchema.parseAsync(data),
      url: "/media",
      ...options,
    });
  }

  /**
   * Create media
   *
   * Create new media.
   */
  public mediaCreate<ThrowOnError extends boolean = false>(
    options: Options<MediaCreateRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      MediaCreateResponses,
      MediaCreateErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await MediaCreateRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await MediaCreateResponseSchema.parseAsync(data),
      url: "/media",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Delete media
   *
   * Delete media by ID.
   */
  public mediaIdDelete<ThrowOnError extends boolean = false>(
    options: Options<MediaIdDeleteRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).delete<
      MediaIdDeleteResponses,
      MediaIdDeleteErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await MediaIdDeleteRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await MediaIdDeleteResponseSchema.parseAsync(data),
      url: "/media/{id}",
      ...options,
    });
  }

  /**
   * Get media
   *
   * Get media by ID.
   */
  public mediaIdGet<ThrowOnError extends boolean = false>(
    options: Options<MediaIdGetRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      MediaIdGetResponses,
      MediaIdGetErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await MediaIdGetRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await MediaIdGetResponseSchema.parseAsync(data),
      url: "/media/{id}",
      ...options,
    });
  }

  /**
   * Update media
   *
   * Update media by ID.
   */
  public mediaIdUpdate<ThrowOnError extends boolean = false>(
    options: Options<MediaIdUpdateRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).patch<
      MediaIdUpdateResponses,
      MediaIdUpdateErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await MediaIdUpdateRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await MediaIdUpdateResponseSchema.parseAsync(data),
      url: "/media/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Download media content
   *
   * Download media content by ID.
   */
  public mediaIdContentDownload<ThrowOnError extends boolean = false>(
    options: Options<MediaIdContentDownloadRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      MediaIdContentDownloadResponses,
      MediaIdContentDownloadErrors,
      ThrowOnError
    >({
      parseAs: "stream",
      requestValidator: async (data) =>
        await MediaIdContentDownloadRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await MediaIdContentDownloadResponseSchema.parseAsync(data),
      url: "/media/{id}/content",
      ...options,
    });
  }

  /**
   * Get media content headers
   *
   * Get media content headers by ID.
   */
  public mediaIdContentHeaddownload<ThrowOnError extends boolean = false>(
    options: Options<MediaIdContentHeaddownloadRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).head<
      MediaIdContentHeaddownloadResponses,
      MediaIdContentHeaddownloadErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await MediaIdContentHeaddownloadRequestSchema.parseAsync(data),
      url: "/media/{id}/content",
      ...options,
    });
  }

  /**
   * Upload media content
   *
   * Upload media content by ID.
   */
  public mediaIdContentUpload<ThrowOnError extends boolean = false>(
    options: Options<MediaIdContentUploadRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).put<
      MediaIdContentUploadResponses,
      MediaIdContentUploadErrors,
      ThrowOnError
    >({
      bodySerializer: null,
      // @ts-expect-error
      duplex: "half",
      requestValidator: async (data) =>
        await MediaIdContentUploadRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await MediaIdContentUploadResponseSchema.parseAsync(data),
      url: "/media/{id}/content",
      ...options,
    });
  }

  /**
   * Ping
   *
   * Ping.
   */
  public pingPing<ThrowOnError extends boolean = false>(
    options?: Options<PingPingRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      PingPingResponses,
      unknown,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PingPingRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PingPingResponseSchema.parseAsync(data),
      url: "/ping",
      ...options,
    });
  }

  /**
   * Ping headers
   *
   * Ping headers.
   */
  public pingHeadping<ThrowOnError extends boolean = false>(
    options?: Options<PingHeadpingRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).head<
      PingHeadpingResponses,
      unknown,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PingHeadpingRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PingHeadpingResponseSchema.parseAsync(data),
      url: "/ping",
      ...options,
    });
  }

  /**
   * List playlists
   *
   * List playlists that match the request.
   */
  public playlistsList<ThrowOnError extends boolean = false>(
    options?: Options<PlaylistsListRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      PlaylistsListResponses,
      PlaylistsListErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PlaylistsListRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PlaylistsListResponseSchema.parseAsync(data),
      url: "/playlists",
      ...options,
    });
  }

  /**
   * Create playlist
   *
   * Create a new playlist.
   */
  public playlistsCreate<ThrowOnError extends boolean = false>(
    options: Options<PlaylistsCreateRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).post<
      PlaylistsCreateResponses,
      PlaylistsCreateErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PlaylistsCreateRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PlaylistsCreateResponseSchema.parseAsync(data),
      url: "/playlists",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Delete playlist
   *
   * Delete a playlist by ID.
   */
  public playlistsIdDelete<ThrowOnError extends boolean = false>(
    options: Options<PlaylistsIdDeleteRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).delete<
      PlaylistsIdDeleteResponses,
      PlaylistsIdDeleteErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PlaylistsIdDeleteRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PlaylistsIdDeleteResponseSchema.parseAsync(data),
      url: "/playlists/{id}",
      ...options,
    });
  }

  /**
   * Get playlist
   *
   * Get a playlist by ID.
   */
  public playlistsIdGet<ThrowOnError extends boolean = false>(
    options: Options<PlaylistsIdGetRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      PlaylistsIdGetResponses,
      PlaylistsIdGetErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PlaylistsIdGetRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PlaylistsIdGetResponseSchema.parseAsync(data),
      url: "/playlists/{id}",
      ...options,
    });
  }

  /**
   * Update playlist
   *
   * Update a playlist by ID.
   */
  public playlistsIdUpdate<ThrowOnError extends boolean = false>(
    options: Options<PlaylistsIdUpdateRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).patch<
      PlaylistsIdUpdateResponses,
      PlaylistsIdUpdateErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PlaylistsIdUpdateRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PlaylistsIdUpdateResponseSchema.parseAsync(data),
      url: "/playlists/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
    });
  }

  /**
   * Get playlist in M3U format
   *
   * Get a playlist in M3U format.
   */
  public playlistsIdM3Um3U<ThrowOnError extends boolean = false>(
    options: Options<PlaylistsIdM3Um3uRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).get<
      PlaylistsIdM3Um3uResponses,
      PlaylistsIdM3Um3uErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PlaylistsIdM3Um3uRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await PlaylistsIdM3Um3uResponseSchema.parseAsync(data),
      url: "/playlists/{id}/m3u",
      ...options,
    });
  }

  /**
   * Get headers for playlist in M3U format
   *
   * Get headers for a playlist in M3U format.
   */
  public playlistsIdM3uHeadm3U<ThrowOnError extends boolean = false>(
    options: Options<PlaylistsIdM3uHeadm3uRequest, ThrowOnError>,
  ) {
    return (options.client ?? this.client).head<
      PlaylistsIdM3uHeadm3uResponses,
      PlaylistsIdM3uHeadm3uErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await PlaylistsIdM3uHeadm3uRequestSchema.parseAsync(data),
      url: "/playlists/{id}/m3u",
      ...options,
    });
  }

  /**
   * Get SSE stream
   *
   * Get a stream of Server-Sent Events.
   */
  public sseSubscribe<ThrowOnError extends boolean = false>(
    options?: Options<SseSubscribeRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).sse.get<
      SseSubscribeResponses,
      SseSubscribeErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await SseSubscribeRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await SseSubscribeResponseSchema.parseAsync(data),
      url: "/sse",
      ...options,
    });
  }

  /**
   * Test
   *
   * Test.
   */
  public testTest<ThrowOnError extends boolean = false>(
    options?: Options<TestTestRequest, ThrowOnError>,
  ) {
    return (options?.client ?? this.client).get<
      TestTestResponses,
      TestTestErrors,
      ThrowOnError
    >({
      requestValidator: async (data) =>
        await TestTestRequestSchema.parseAsync(data),
      responseValidator: async (data) =>
        await TestTestResponseSchema.parseAsync(data),
      url: "/test",
      ...options,
    });
  }
}
